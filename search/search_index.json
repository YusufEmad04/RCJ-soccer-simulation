{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to RCJ Soccer Sim! This is the official repository of the RoboCupJunior Soccer Simulator. The simulator is based on Webots and this repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules ) as well as a sample simulated team of robots with some basic strategy. How do I try this out? Setting up is easy: Getting started How to program your robot How to communicate between robots How to run the simulation Please do not hesitate to ask any questions on the forum .","title":"Introduction"},{"location":"#welcome-to-rcj-soccer-sim","text":"This is the official repository of the RoboCupJunior Soccer Simulator. The simulator is based on Webots and this repository provides both the \"automatic referee\" (which implements the Soccer Simulated Rules ) as well as a sample simulated team of robots with some basic strategy.","title":"Welcome to RCJ Soccer Sim!"},{"location":"#how-do-i-try-this-out","text":"Setting up is easy: Getting started How to program your robot How to communicate between robots How to run the simulation Please do not hesitate to ask any questions on the forum .","title":"How do I try this out?"},{"location":"communication_between_robots/","text":"Communication between robots Each of the robots is equipped with two Receivers and one Emitter. One of the Receivers is used for receiving data from Supervisor. The Emitter and the second Receiver can be used for sending and receiving data between robots from the same team. We are going to describe what needs to be done in order to make use of it. Definition in the world file Our world file defines one Emitter and one Receiver for team communication for each robot. Blue team is assigned channel 2, while yellow team is assigned channel 3. Webots supports changing channels, but we turned this feature off so teams are not able to spam the opponent with a bunch of messages. The name of the Emitter is set to team emitter , while the Receiver can be found under name team receiver . Initializing the communication The first thing we need to do in order to setup the communication is initialize the Emitter and Receiver. To do so, just call following commands. We are going to use the OOP approach here as well (see our sample robot controllers). self . team_emitter = self . robot . getDevice ( \"team emitter\" ) self . team_receiver = self . robot . getDevice ( \"team receiver\" ) self . team_receiver . enable ( TIME_STEP ) Before using the Receiver, we must enable it with enable(TIME_STEP) command, where TIME_STEP is the same value we use in our controller when calling self.robot.step(TIME_STEP) . Sending a message Each time we send a message via a channel, all the receivers listening on this channel are going to receive it. So, if robot1 sends a message, robot2 and robot3 from the same team can read it. Converting the message into a packet Imagine we would like to send values v1 , v2 , ... , vn . Before the message is sent to the channel, it must be converted into a packet. Simply put, the packet is just a bytes object representing values v1 , v2 , ... , vn . To convert our values into bytes object we can use built-in library called struct , which is shipped together with Python. We need to know the type of each value we want to pack into a packet. Let's see a quick example. The values we want to send are v1 = 3.14 , v2 = 5 and v3 = True . It is obvious that v1 is floating point number, v2 is integer and v3 is boolean. Knowing the type of each variable, we need to define the structure of the message. message_format = \"di?\" The struct library defines various symbols we might use in order to represent a variable type. In our example \"d\" is representing floating point number, \"i\" is representing integer and \"?\" is representing boolean value. If you want to use other variable types, check out the struct format characters documentation . Since we now know the structure of the message, we can create the packet packet = struct . pack ( message_format , v1 , v2 , v3 ) Keep in mind that the order of variables passed to pack() function MUST be in the same order as specified in message_format , otherwise you might get a broken packet. The only thing we need to do is emit the packet by the Emitter. It is as easy as just calling self . team_emitter . send ( packet ) and the message is succesfully sent to the channel. Receiving a message When a Receiver receives a message, it adds it to the queue. We are then able to pull the oldest message out of the queue. To check the number of messages waiting in the queue, we can call self . team_receiver . getQueueLength () If the there are new messages, the number of messages will be greater than 0 and we can proceed with reading the message. packet = self . team_receiver . getData () self . team_receiver . nextPacket () In the first row we call the getData() method, which returns the packet and assigns it to the packet variable. The nextPacket() method is used to move the pointer to the next packet in the queue, so next time we are calling getData() , we are going to read next packet in the queue. Okay, now we have packet. How do we unpack it? Well, remember our cool struct library? We are going to use it for unpacking the packet, too. First of all, we need to know what data we expect. In our example, we sent three variables in this order - floating point number, integer and boolean. Therefore, we can define the format of the message here as well. message_format = 'di?' Knowing what data to expect, we can unpack the packet by following command: unpacked = struct . unpack ( message_format , packet ) The variable unpacked is a tuple with our values. If we print it, we will get (3.14, 5, True) . We can access the values as we would for list (or array in other languages) v1 = unpacked [ 0 ] v2 = unpacked [ 1 ] v3 = unpacked [ 2 ] WARNING: There are 3 robots within the team running asynchronously. If all of them are sending messages, it is always good to empty the queue before moving on, otherwise the queue might grow and you will be reading old messages. You can use a while loop for example while self . team_receiver . getQueueLength () > 0 : packet = self . team_receiver . getData () self . team_receiver . nextPacket () # Do something with the packet","title":"Inter-robot communication"},{"location":"communication_between_robots/#communication-between-robots","text":"Each of the robots is equipped with two Receivers and one Emitter. One of the Receivers is used for receiving data from Supervisor. The Emitter and the second Receiver can be used for sending and receiving data between robots from the same team. We are going to describe what needs to be done in order to make use of it.","title":"Communication between robots"},{"location":"communication_between_robots/#definition-in-the-world-file","text":"Our world file defines one Emitter and one Receiver for team communication for each robot. Blue team is assigned channel 2, while yellow team is assigned channel 3. Webots supports changing channels, but we turned this feature off so teams are not able to spam the opponent with a bunch of messages. The name of the Emitter is set to team emitter , while the Receiver can be found under name team receiver .","title":"Definition in the world file"},{"location":"communication_between_robots/#initializing-the-communication","text":"The first thing we need to do in order to setup the communication is initialize the Emitter and Receiver. To do so, just call following commands. We are going to use the OOP approach here as well (see our sample robot controllers). self . team_emitter = self . robot . getDevice ( \"team emitter\" ) self . team_receiver = self . robot . getDevice ( \"team receiver\" ) self . team_receiver . enable ( TIME_STEP ) Before using the Receiver, we must enable it with enable(TIME_STEP) command, where TIME_STEP is the same value we use in our controller when calling self.robot.step(TIME_STEP) .","title":"Initializing the communication"},{"location":"communication_between_robots/#sending-a-message","text":"Each time we send a message via a channel, all the receivers listening on this channel are going to receive it. So, if robot1 sends a message, robot2 and robot3 from the same team can read it.","title":"Sending a message"},{"location":"communication_between_robots/#converting-the-message-into-a-packet","text":"Imagine we would like to send values v1 , v2 , ... , vn . Before the message is sent to the channel, it must be converted into a packet. Simply put, the packet is just a bytes object representing values v1 , v2 , ... , vn . To convert our values into bytes object we can use built-in library called struct , which is shipped together with Python. We need to know the type of each value we want to pack into a packet. Let's see a quick example. The values we want to send are v1 = 3.14 , v2 = 5 and v3 = True . It is obvious that v1 is floating point number, v2 is integer and v3 is boolean. Knowing the type of each variable, we need to define the structure of the message. message_format = \"di?\" The struct library defines various symbols we might use in order to represent a variable type. In our example \"d\" is representing floating point number, \"i\" is representing integer and \"?\" is representing boolean value. If you want to use other variable types, check out the struct format characters documentation . Since we now know the structure of the message, we can create the packet packet = struct . pack ( message_format , v1 , v2 , v3 ) Keep in mind that the order of variables passed to pack() function MUST be in the same order as specified in message_format , otherwise you might get a broken packet. The only thing we need to do is emit the packet by the Emitter. It is as easy as just calling self . team_emitter . send ( packet ) and the message is succesfully sent to the channel.","title":"Converting the message into a packet"},{"location":"communication_between_robots/#receiving-a-message","text":"When a Receiver receives a message, it adds it to the queue. We are then able to pull the oldest message out of the queue. To check the number of messages waiting in the queue, we can call self . team_receiver . getQueueLength () If the there are new messages, the number of messages will be greater than 0 and we can proceed with reading the message. packet = self . team_receiver . getData () self . team_receiver . nextPacket () In the first row we call the getData() method, which returns the packet and assigns it to the packet variable. The nextPacket() method is used to move the pointer to the next packet in the queue, so next time we are calling getData() , we are going to read next packet in the queue. Okay, now we have packet. How do we unpack it? Well, remember our cool struct library? We are going to use it for unpacking the packet, too. First of all, we need to know what data we expect. In our example, we sent three variables in this order - floating point number, integer and boolean. Therefore, we can define the format of the message here as well. message_format = 'di?' Knowing what data to expect, we can unpack the packet by following command: unpacked = struct . unpack ( message_format , packet ) The variable unpacked is a tuple with our values. If we print it, we will get (3.14, 5, True) . We can access the values as we would for list (or array in other languages) v1 = unpacked [ 0 ] v2 = unpacked [ 1 ] v3 = unpacked [ 2 ] WARNING: There are 3 robots within the team running asynchronously. If all of them are sending messages, it is always good to empty the queue before moving on, otherwise the queue might grow and you will be reading old messages. You can use a while loop for example while self . team_receiver . getQueueLength () > 0 : packet = self . team_receiver . getData () self . team_receiver . nextPacket () # Do something with the packet","title":"Receiving a message"},{"location":"getting_started/","text":"How do I try this out? It's easy, you can set it up in about 10 minutes! (plus download time) Installation Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help! Download Webots from their official website. Currently, version R2022a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide . Clone the rcj-soccer-sim repository to your computer by downloading the ZIP file from here or running git clone https://github.com/RoboCupJuniorTC/rcj-soccer-sim.git Finally, run Webots, go to Tools > Preferences > Python command and set it to python or python3 to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command python or python3 . More information on how to configure Webots to work with Python can be found here . Running Soccer Sim Use Webots to open the downloaded soccer.wbt world located in the worlds directory (via File > Open World ) Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the various robots on the field can be found in the controllers/ directory. Notes A specific webots world can be executed directly from the command line as follows: webots --mode=run worlds/soccer.wbt Which allows for at least some automation. Further info can be found in the docs . The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.","title":"Getting Started"},{"location":"getting_started/#how-do-i-try-this-out","text":"It's easy, you can set it up in about 10 minutes! (plus download time)","title":"How do I try this out?"},{"location":"getting_started/#installation","text":"Install Python 3.7 (or higher) 64 bit from the official website (please make sure it is version 3.7 or higher for Windows, and 3.8 or higher if installing on MacOS or Linux). On Windows, please make sure your Python is referenced in Windows PATH by selecting the option \"Add Python 3.x to PATH\" during the installation. Check out this great installation guide if you need some help! Download Webots from their official website. Currently, version R2022a is stable with the Soccer Simulator. You can find detailed installation procedure on the official Webots Installation guide . Clone the rcj-soccer-sim repository to your computer by downloading the ZIP file from here or running git clone https://github.com/RoboCupJuniorTC/rcj-soccer-sim.git Finally, run Webots, go to Tools > Preferences > Python command and set it to python or python3 to point Webots to Python 3. Depending on your system, the reference to Python 3 can be via the command python or python3 . More information on how to configure Webots to work with Python can be found here .","title":"Installation"},{"location":"getting_started/#running-soccer-sim","text":"Use Webots to open the downloaded soccer.wbt world located in the worlds directory (via File > Open World ) Run/pause the simulation by clicking the corresponding buttons on the top-part of Webots window. Note that the controllers that are responsible for the various robots on the field can be found in the controllers/ directory.","title":"Running Soccer Sim"},{"location":"getting_started/#notes","text":"A specific webots world can be executed directly from the command line as follows: webots --mode=run worlds/soccer.wbt Which allows for at least some automation. Further info can be found in the docs . The sample players as well as the \"automatic referee\" are implemented in Python, which should allow for easily updating the code to match the rules and avoid any compilation issues.","title":"Notes"},{"location":"how_to_robot/","text":"How to program your robot Controllers Each object in the simulation world can be controlled by a program. This program is called Controller . Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules. The controllers are located in the controllers directory. The name of the controller must be located in a subfolder with the same name (i.e. robot/robot.py ) and this name ought to be specified in soccer.wbt file. Hello world, robot! We have prepared a few sample robot controllers. They can be found in the controllers directory. The controllers for the robots of blue team are located in rcj_soccer_team_blue folder and for the robots of yellow team in rcj_soccer_team_yellow folder, respectively. Team folders contain a file called rcj_soccer_team_blue.py (blue team) or rcj_soccer_team_yellow.py (yellow team). Each of the robots initially runs this file (for the competition, it should be robot.py ). Based on the unique identifier of the robot (which can be 1 , 2 or 3 ) we initialize the code for the particular robot. Script for determining and initializing the robot controller A sample initial file might look as follows: from controller import Robot from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 robot = Robot () name = robot . getName () robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) robot_controller . run () Let's describe a file for determining robot's name and running specific controller. from controller import Robot The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots. from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 Since all of robot controllers are located in the same directory, we can easily import them. robot = Robot () name = robot . getName () Initialize robot instance and get the name of the robot. The name is one of the following {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) By checking the second character in the name, we can easily get the number identifier of the robot and initialize its controller appropriately. robot_controller . run () We just call the method run in order to execute the code for the specific robot we initialized previously. Robot controller Let's put together a simple program to showcase how you can go about programming a robot. import struct TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) class MyRobot : def __init__ ( self , robot ): self . robot = robot self . name = self . robot . getName () self . receiver = self . robot . getDevice ( \"supervisor receiver\" ) self . receiver . enable ( TIME_STEP ) self . ball_receiver = self . robot . getDevice ( \"ball receiver\" ) self . ball_receiver . enable ( TIME_STEP ) self . gps = self . robot . getDevice ( \"gps\" ) self . gps . enable ( TIME_STEP ) self . compass = self . robot . getDevice ( \"compass\" ) self . compass . enable ( TIME_STEP ) self . sonar_left = self . robot . getDevice ( \"distancesensor left\" ) self . sonar_left . enable ( TIME_STEP ) self . sonar_right = self . robot . getDevice ( \"distancesensor right\" ) self . sonar_right . enable ( TIME_STEP ) self . sonar_front = self . robot . getDevice ( \"distancesensor front\" ) self . sonar_front . enable ( TIME_STEP ) self . sonar_back = self . robot . getDevice ( \"distancesensor back\" ) self . sonar_back . enable ( TIME_STEP ) self . left_motor = self . robot . getDevice ( \"left wheel motor\" ) self . right_motor = self . robot . getDevice ( \"right wheel motor\" ) self . left_motor . setPosition ( float ( '+inf' )) self . right_motor . setPosition ( float ( '+inf' )) self . left_motor . setVelocity ( 0.0 ) self . right_motor . setVelocity ( 0.0 ) def get_new_data ( self ): packet = self . receiver . getData () self . receiver . nextPacket () struct_fmt = '?' unpacked = struct . unpack ( struct_fmt , packet ) data = { \"waiting_for_kickoff\" : unpacked [ 0 ] } return data def run ( self ): while self . robot . step ( TIME_STEP ) != - 1 : if self . receiver . getQueueLength () > 0 : data = self . get_new_data () # Get data from compass heading = self . get_compass_heading () # Get GPS coordinates of the robot robot_pos = self . get_gps_coordinates () # Get data from sonars sonar_values = self . get_sonar_values () # Get direction and strength of the IR signal if self . is_new_ball_data (): ball_data = self . get_new_ball_data () self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) Let's explain the code in detail: import struct This library is a built-in Python library , which is required to unpack the data sent by the supervisor. TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) We also define some useful constants, whose values will be used later. class MyRobot : You can wrap the program into the class as we did. The benefit of OOP ( Object Oriented Programming ) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach. def __init__ ( self , robot ): self . robot = robot self . name = self . robot . getName () ... The __init__ function is something like a constructor of the class and is called when an instance of the MyRobot object is created. We use this function to initialize some important variables. The most important one is the Robot instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed), receiver (for reading data from Supervisor), and sensors like GPS, Compass, Sonars or IR Ball receiver. The name and the team of your robot can be determined by calling self.robot.getName() . It will give you one of {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. If you want to know the side of your team (either \"Blue\" or \"Yellow\"), you can find out by checking self.name[0] , which essentially gives you \"B\" for Blue or \"Y\" for Yellow side. def get_new_data ( self ): ... We are not going to explain this deeply. This function simply parses the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary just contains a single bit of information: whether a goal was scored and we are waiting for a new kickoff. In case the goal gets scored, the value is True and is reset to False when the referee fires new kickoff. def run ( self ): This is the method which contains the logic for controlling the robot. As mentioned previously, it is called by our initialization script. while self . robot . step ( TIME_STEP ) != - 1 : The step function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers. if self . receiver . getQueueLength () > 0 : Before reading data, it is important to check if there is actually something in the queue that we can read. data = self . get_new_data () heading = self . get_compass_heading () robot_pos = self . get_gps_coordinates () sonar_values = self . get_sonar_values () if self . is_new_ball_data (): ball_data = self . get_new_ball_data () self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) And finally, after reading the new data received from supervisor as well as data from sensors we do some calculations and set the speed of the motors. Available sensors GPS This sensor gives you the exact position of the robot. For more information check official GPS documentation . In rcj_soccer_robot.py you can find get_gps_coordinates() , which demonstrates how to work with GPS sensor. Compass Useful sensor to determine the angle (rotation) of the robot from the north. For more information check official compass documentation . In rcj_soccer_robot.py you can find get_compass_heading() , which demonstrates how to work with compass sensor. Sonars There are four sonars mounted on the robot (each side having one). Since the exact position of the robot may be retrieved from GPS, these sensors are useful for detecting the opponent's robots. For more information check official distance sensor documentation . Note that you may encounter some error in measurements. When the robot is next to an obstacle, the value returned is 0 with error of 0%. On the other hand, when the sesnsor does not see anything, the value returned is 1000 with error of 5%. The values and errors in between are linearly interpolated. In rcj_soccer_robot.py you can find get_sonar_values() , which demonstrates how to work with sonar sensors. For debugging purposes, you may find it useful to turn on rendering rays of distance sensors. This option is available in Webots GUI under View -> Optional Rendering -> Show DistanceSensor Rays . Ball IR Sensor There is an infra-red emitter mounted onto the ball. The emitter just emits a signal and each robot receives this signal if it is located within a pre-defined range. The receiver is able to determine the direction as well as strength of the signal, which can be used for navigating robots towards the ball. For more information check the official receiver documentation or our get_new_ball_data() method in rcj_soccer_robot.py . Importing shared code Each team consists of three robots. These robots might share some of the code and it is actually a good practice not to duplicate code all over the place. Imagine you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py and within robot1.py , robot2.py and robot3.py you want to import some useful code from utils.py . You can easily import it by calling import utils and use the shared code rather than copying it into each of the controllers. Do not import anything from robot.py file, otherwise you might get cyclic import problem. Supported external libraries In general, the whole Python's standard library can be used in the robot's programs. Furthermore, to make the computations easier, the Soccer Sim environment supports the following two Python libraries that are normally used for what's called \"scientific computing\": numpy (version 1.20.2) scipy (version 1.6.3)","title":"How to program your robot"},{"location":"how_to_robot/#how-to-program-your-robot","text":"","title":"How to program your robot"},{"location":"how_to_robot/#controllers","text":"Each object in the simulation world can be controlled by a program. This program is called Controller . Each robot should have exactly one controller, implemented as a Python3 program. There is an invisible referee object in the simulation, which takes care of controlling the game and checking the rules. The controllers are located in the controllers directory. The name of the controller must be located in a subfolder with the same name (i.e. robot/robot.py ) and this name ought to be specified in soccer.wbt file.","title":"Controllers"},{"location":"how_to_robot/#hello-world-robot","text":"We have prepared a few sample robot controllers. They can be found in the controllers directory. The controllers for the robots of blue team are located in rcj_soccer_team_blue folder and for the robots of yellow team in rcj_soccer_team_yellow folder, respectively. Team folders contain a file called rcj_soccer_team_blue.py (blue team) or rcj_soccer_team_yellow.py (yellow team). Each of the robots initially runs this file (for the competition, it should be robot.py ). Based on the unique identifier of the robot (which can be 1 , 2 or 3 ) we initialize the code for the particular robot.","title":"Hello world, robot!"},{"location":"how_to_robot/#script-for-determining-and-initializing-the-robot-controller","text":"A sample initial file might look as follows: from controller import Robot from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 robot = Robot () name = robot . getName () robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) robot_controller . run () Let's describe a file for determining robot's name and running specific controller. from controller import Robot The Robot class is required to be imported because this is the only way we are able to controll the robot. The Robot class is shipped together with Webots. from robot1 import MyRobot1 from robot2 import MyRobot2 from robot3 import MyRobot3 Since all of robot controllers are located in the same directory, we can easily import them. robot = Robot () name = robot . getName () Initialize robot instance and get the name of the robot. The name is one of the following {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . robot_number = int ( name [ 1 ]) if robot_number == 1 : robot_controller = MyRobot1 ( robot ) elif robot_number == 2 : robot_controller = MyRobot2 ( robot ) else : robot_controller = MyRobot3 ( robot ) By checking the second character in the name, we can easily get the number identifier of the robot and initialize its controller appropriately. robot_controller . run () We just call the method run in order to execute the code for the specific robot we initialized previously.","title":"Script for determining and initializing the robot controller"},{"location":"how_to_robot/#robot-controller","text":"Let's put together a simple program to showcase how you can go about programming a robot. import struct TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) class MyRobot : def __init__ ( self , robot ): self . robot = robot self . name = self . robot . getName () self . receiver = self . robot . getDevice ( \"supervisor receiver\" ) self . receiver . enable ( TIME_STEP ) self . ball_receiver = self . robot . getDevice ( \"ball receiver\" ) self . ball_receiver . enable ( TIME_STEP ) self . gps = self . robot . getDevice ( \"gps\" ) self . gps . enable ( TIME_STEP ) self . compass = self . robot . getDevice ( \"compass\" ) self . compass . enable ( TIME_STEP ) self . sonar_left = self . robot . getDevice ( \"distancesensor left\" ) self . sonar_left . enable ( TIME_STEP ) self . sonar_right = self . robot . getDevice ( \"distancesensor right\" ) self . sonar_right . enable ( TIME_STEP ) self . sonar_front = self . robot . getDevice ( \"distancesensor front\" ) self . sonar_front . enable ( TIME_STEP ) self . sonar_back = self . robot . getDevice ( \"distancesensor back\" ) self . sonar_back . enable ( TIME_STEP ) self . left_motor = self . robot . getDevice ( \"left wheel motor\" ) self . right_motor = self . robot . getDevice ( \"right wheel motor\" ) self . left_motor . setPosition ( float ( '+inf' )) self . right_motor . setPosition ( float ( '+inf' )) self . left_motor . setVelocity ( 0.0 ) self . right_motor . setVelocity ( 0.0 ) def get_new_data ( self ): packet = self . receiver . getData () self . receiver . nextPacket () struct_fmt = '?' unpacked = struct . unpack ( struct_fmt , packet ) data = { \"waiting_for_kickoff\" : unpacked [ 0 ] } return data def run ( self ): while self . robot . step ( TIME_STEP ) != - 1 : if self . receiver . getQueueLength () > 0 : data = self . get_new_data () # Get data from compass heading = self . get_compass_heading () # Get GPS coordinates of the robot robot_pos = self . get_gps_coordinates () # Get data from sonars sonar_values = self . get_sonar_values () # Get direction and strength of the IR signal if self . is_new_ball_data (): ball_data = self . get_new_ball_data () self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) Let's explain the code in detail: import struct This library is a built-in Python library , which is required to unpack the data sent by the supervisor. TIME_STEP = 64 ROBOT_NAMES = [ \"B1\" , \"B2\" , \"B3\" , \"Y1\" , \"Y2\" , \"Y3\" ] N_ROBOTS = len ( ROBOT_NAMES ) We also define some useful constants, whose values will be used later. class MyRobot : You can wrap the program into the class as we did. The benefit of OOP ( Object Oriented Programming ) is that you can later reuse the same common class throughout your controllers and therefore make the code easier to read. We are going to continue with our OOP approach. def __init__ ( self , robot ): self . robot = robot self . name = self . robot . getName () ... The __init__ function is something like a constructor of the class and is called when an instance of the MyRobot object is created. We use this function to initialize some important variables. The most important one is the Robot instance, which allows us to get access to the so called Webots devices like motor (for controlling the speed), receiver (for reading data from Supervisor), and sensors like GPS, Compass, Sonars or IR Ball receiver. The name and the team of your robot can be determined by calling self.robot.getName() . It will give you one of {\"B1\", \"B2\", \"B3\", \"Y1\", \"Y2\", \"Y3\"} . The first letter determines the team (\"Blue\", \"Yellow\"), while the second one is the robot's identifier. If you want to know the side of your team (either \"Blue\" or \"Yellow\"), you can find out by checking self.name[0] , which essentially gives you \"B\" for Blue or \"Y\" for Yellow side. def get_new_data ( self ): ... We are not going to explain this deeply. This function simply parses the incoming data from supervisor. Feel free to copy and use it. The resulting dictionary just contains a single bit of information: whether a goal was scored and we are waiting for a new kickoff. In case the goal gets scored, the value is True and is reset to False when the referee fires new kickoff. def run ( self ): This is the method which contains the logic for controlling the robot. As mentioned previously, it is called by our initialization script. while self . robot . step ( TIME_STEP ) != - 1 : The step function is crucial and must be used in every controller. This function synchronizes the sensor and actuator data between Webots and the controllers. if self . receiver . getQueueLength () > 0 : Before reading data, it is important to check if there is actually something in the queue that we can read. data = self . get_new_data () heading = self . get_compass_heading () robot_pos = self . get_gps_coordinates () sonar_values = self . get_sonar_values () if self . is_new_ball_data (): ball_data = self . get_new_ball_data () self . left_motor . setVelocity ( 1 ) self . right_motor . setVelocity ( - 1 ) And finally, after reading the new data received from supervisor as well as data from sensors we do some calculations and set the speed of the motors.","title":"Robot controller"},{"location":"how_to_robot/#available-sensors","text":"","title":"Available sensors"},{"location":"how_to_robot/#gps","text":"This sensor gives you the exact position of the robot. For more information check official GPS documentation . In rcj_soccer_robot.py you can find get_gps_coordinates() , which demonstrates how to work with GPS sensor.","title":"GPS"},{"location":"how_to_robot/#compass","text":"Useful sensor to determine the angle (rotation) of the robot from the north. For more information check official compass documentation . In rcj_soccer_robot.py you can find get_compass_heading() , which demonstrates how to work with compass sensor.","title":"Compass"},{"location":"how_to_robot/#sonars","text":"There are four sonars mounted on the robot (each side having one). Since the exact position of the robot may be retrieved from GPS, these sensors are useful for detecting the opponent's robots. For more information check official distance sensor documentation . Note that you may encounter some error in measurements. When the robot is next to an obstacle, the value returned is 0 with error of 0%. On the other hand, when the sesnsor does not see anything, the value returned is 1000 with error of 5%. The values and errors in between are linearly interpolated. In rcj_soccer_robot.py you can find get_sonar_values() , which demonstrates how to work with sonar sensors. For debugging purposes, you may find it useful to turn on rendering rays of distance sensors. This option is available in Webots GUI under View -> Optional Rendering -> Show DistanceSensor Rays .","title":"Sonars"},{"location":"how_to_robot/#ball-ir-sensor","text":"There is an infra-red emitter mounted onto the ball. The emitter just emits a signal and each robot receives this signal if it is located within a pre-defined range. The receiver is able to determine the direction as well as strength of the signal, which can be used for navigating robots towards the ball. For more information check the official receiver documentation or our get_new_ball_data() method in rcj_soccer_robot.py .","title":"Ball IR Sensor"},{"location":"how_to_robot/#importing-shared-code","text":"Each team consists of three robots. These robots might share some of the code and it is actually a good practice not to duplicate code all over the place. Imagine you have the folder structure which looks like this controllers/ \u251c\u2500\u2500 robot/ \u2502 \u2514\u2500\u2500 robot.py \u2502 \u2514\u2500\u2500 robot1.py \u2502 \u2514\u2500\u2500 robot2.py \u2502 \u2514\u2500\u2500 robot3.py | \u2514\u2500\u2500 utils.py and within robot1.py , robot2.py and robot3.py you want to import some useful code from utils.py . You can easily import it by calling import utils and use the shared code rather than copying it into each of the controllers. Do not import anything from robot.py file, otherwise you might get cyclic import problem.","title":"Importing shared code"},{"location":"how_to_robot/#supported-external-libraries","text":"In general, the whole Python's standard library can be used in the robot's programs. Furthermore, to make the computations easier, the Soccer Sim environment supports the following two Python libraries that are normally used for what's called \"scientific computing\": numpy (version 1.20.2) scipy (version 1.6.3)","title":"Supported external libraries"},{"location":"how_to_run_sim/","text":"Running the simulator Note: This document is intended for the organizers of events in which the RCJ Soccer Sim is to be used This document outlines how the RoboCupJunior Soccer Sim can be used to simulate a match in a \"headless\" way. In other words, it shows how you can go from having the code for two teams and the RoboCupJunior Soccer Sim code to getting an output in form of either an MPEG-4 video or a HTML site. Input Source code for the yellow team Source code for the blue team RoboCupJunior Soccer Sim Output MPEG-4 video and/or HTML site JSON file containing all the important events happened during the game Preliminaries This guide makes a couple of assumptions: You use an UNIX-like environment (i.e. something like Linux or macOS) You have Webots installed and cloned the rcj-soccer-sim repository locally (check the Getting Started guide on how to do so) Running Soccer Sim (and Webots) in Automatic Mode As Webots docs state, it can also be started from a Terminal, or a command line prompt. The most basic command would look as follows: webots --mode=fast worlds/soccer.wbt This opens up Webots and automatically starts the game in the GUI. You can then either pause the game, restart it or even manually setup the video/HTML export. Soccer Sim's referee has the ability to automatically start the recording and stop the execution when it finishes. To do so, the RCJ_SIM_AUTO_MODE environment variable needs to be set (the value doesn't matter but we suggest True or something of that sort). Furthermore, to make sure the game is recorded, a recording format needs to be specified. This is done via the RCJ_SIM_REC_FORMATS environment variable and all the options are documented in the section below. In summary, to automatically run the world/soccer.wbt world file (the Soccer environment) and record the output in HTML format, the following command can be used: RCJ_SIM_AUTO_MODE=True RCJ_SIM_REC_FORMATS=x3d webots --mode=fast worlds/soccer.wbt Running Soccer Sim in Docker To simplify the automatic running of games, Soccer Sim can also be executed inside a Docker container. We generally recommend using the offical container provided by Webots and mentioned in the official guide . Assuming the rcj-soccer-sim repository is located in the current directory, running Soccer Sim within docker is as simple as executing docker run \\ -v $(pwd)/rcj-soccer-sim:/rcj-soccer-sim \\ -e RCJ_SIM_AUTO_MODE=True \\ -e RCJ_SIM_REC_FORMATS=x3d \\ cyberbotics/webots:latest /rcj-soccer-sim/run-in-docker.sh /rcj-soccer-sim/worlds/soccer.wbt Let us briefly discuss the respective lines. On the first one the docker command starts the Docker container, on the second one, the rcj-soccer-sim folder in the current directory is mapped to /rcj-soccer-sim in the container, on the following two the RCJ_SIM_AUTO_MODE and RCJ_SIM_REC_FORMATS environment variables are being set and on the last one the worlds/soccer.wbt world from the rcj-soccer-sim repository is executed in the Webex environment using the run-in-docker.sh script (also part of the very same repository). Extracting the recorded output By default, the output (recording and reflog) of a match is saved in the reflog/ folder in controllers/rcj_soccer_referee_supervisor/ of the rcj-soccer-sim repository. This is relatively inconveniet when it comes to running multiple games and getting data out of the Docker container and hence the path can be changed using the RCJ_SIM_OUTPUT_PATH environment variable. The command below redirects the output to the /tmp/outputs directory inside the container and maps it to the outputs/ directory in the current working directory on the host: docker run \\ -v $(pwd)/rcj-soccer-sim:/rcj-soccer-sim \\ -v $(pwd)/outputs:/tmp/outputs \\ -e RCJ_SIM_AUTO_MODE=True \\ -e RCJ_SIM_REC_FORMATS=x3d \\ -e RCJ_SIM_OUTPUT_PATH=/tmp/outputs/ \\ cyberbotics/webots:latest /rcj-soccer-sim/run-in-docker.sh /rcj-soccer-sim/worlds/soccer.wbt Environment variables The full list of environment variables supported by the Soccer Sim can be found below: RCJ_SIM_AUTO_MODE : If set (to any value), the simulation speed is set to fast, the recorders are started at the beginning and the application is automatically closed after the match is finished. Not set by default. RCJ_SIM_MATCH_TIME : Sets the number of seconds for which the match is to be played. Defaults to 600 (10 minutes). RCJ_SIM_REC_FORMATS : When set, the Soccer Sim starts a recording in these formats. The available options are mp4 and x3d . Multiple options can be set as well, separated by a comma. Not set by default. RCJ_SIM_OUTPUT_PATH : The path where the reflog outputs as well as the recordings are to be saved. Defaults to the reflog/ folder in controllers/rcj_soccer_referee_supervisor/ . Internal team-related variables: RCJ_SIM_TEAM_YELLOW_NAME : The name of the yellow team. Defaults to \"The Yellows\". RCJ_SIM_TEAM_Y_INITIAL_SCORE : The initial score of the yellow team. Defaults to 0. RCJ_SIM_TEAM_BLUE_NAME : The name of the blue team. Defaults to \"The Blues\". RCJ_SIM_TEAM_B_INITIAL_SCORE : The initial score of the blue team. Defaults to 0. RCJ_SIM_TEAM_YELLOW_ID : The ID of the yellow team used for internal identification. Defaults to \"The Yellows\". RCJ_SIM_TEAM_BLUE_ID : The ID of the yellow team used for internal identification. Defaults to \"The Blues\". RCJ_SIM_MATCH_ID : The ID of the match used for internal identification. Defaults to 1. RCJ_SIM_HALF_ID : The ID of the half time used for internal identification. Defaults to 1.","title":"How to run the simulation"},{"location":"how_to_run_sim/#running-the-simulator","text":"Note: This document is intended for the organizers of events in which the RCJ Soccer Sim is to be used This document outlines how the RoboCupJunior Soccer Sim can be used to simulate a match in a \"headless\" way. In other words, it shows how you can go from having the code for two teams and the RoboCupJunior Soccer Sim code to getting an output in form of either an MPEG-4 video or a HTML site. Input Source code for the yellow team Source code for the blue team RoboCupJunior Soccer Sim Output MPEG-4 video and/or HTML site JSON file containing all the important events happened during the game","title":"Running the simulator"},{"location":"how_to_run_sim/#preliminaries","text":"This guide makes a couple of assumptions: You use an UNIX-like environment (i.e. something like Linux or macOS) You have Webots installed and cloned the rcj-soccer-sim repository locally (check the Getting Started guide on how to do so)","title":"Preliminaries"},{"location":"how_to_run_sim/#running-soccer-sim-and-webots-in-automatic-mode","text":"As Webots docs state, it can also be started from a Terminal, or a command line prompt. The most basic command would look as follows: webots --mode=fast worlds/soccer.wbt This opens up Webots and automatically starts the game in the GUI. You can then either pause the game, restart it or even manually setup the video/HTML export. Soccer Sim's referee has the ability to automatically start the recording and stop the execution when it finishes. To do so, the RCJ_SIM_AUTO_MODE environment variable needs to be set (the value doesn't matter but we suggest True or something of that sort). Furthermore, to make sure the game is recorded, a recording format needs to be specified. This is done via the RCJ_SIM_REC_FORMATS environment variable and all the options are documented in the section below. In summary, to automatically run the world/soccer.wbt world file (the Soccer environment) and record the output in HTML format, the following command can be used: RCJ_SIM_AUTO_MODE=True RCJ_SIM_REC_FORMATS=x3d webots --mode=fast worlds/soccer.wbt","title":"Running Soccer Sim (and Webots) in Automatic Mode"},{"location":"how_to_run_sim/#running-soccer-sim-in-docker","text":"To simplify the automatic running of games, Soccer Sim can also be executed inside a Docker container. We generally recommend using the offical container provided by Webots and mentioned in the official guide . Assuming the rcj-soccer-sim repository is located in the current directory, running Soccer Sim within docker is as simple as executing docker run \\ -v $(pwd)/rcj-soccer-sim:/rcj-soccer-sim \\ -e RCJ_SIM_AUTO_MODE=True \\ -e RCJ_SIM_REC_FORMATS=x3d \\ cyberbotics/webots:latest /rcj-soccer-sim/run-in-docker.sh /rcj-soccer-sim/worlds/soccer.wbt Let us briefly discuss the respective lines. On the first one the docker command starts the Docker container, on the second one, the rcj-soccer-sim folder in the current directory is mapped to /rcj-soccer-sim in the container, on the following two the RCJ_SIM_AUTO_MODE and RCJ_SIM_REC_FORMATS environment variables are being set and on the last one the worlds/soccer.wbt world from the rcj-soccer-sim repository is executed in the Webex environment using the run-in-docker.sh script (also part of the very same repository).","title":"Running Soccer Sim in Docker"},{"location":"how_to_run_sim/#extracting-the-recorded-output","text":"By default, the output (recording and reflog) of a match is saved in the reflog/ folder in controllers/rcj_soccer_referee_supervisor/ of the rcj-soccer-sim repository. This is relatively inconveniet when it comes to running multiple games and getting data out of the Docker container and hence the path can be changed using the RCJ_SIM_OUTPUT_PATH environment variable. The command below redirects the output to the /tmp/outputs directory inside the container and maps it to the outputs/ directory in the current working directory on the host: docker run \\ -v $(pwd)/rcj-soccer-sim:/rcj-soccer-sim \\ -v $(pwd)/outputs:/tmp/outputs \\ -e RCJ_SIM_AUTO_MODE=True \\ -e RCJ_SIM_REC_FORMATS=x3d \\ -e RCJ_SIM_OUTPUT_PATH=/tmp/outputs/ \\ cyberbotics/webots:latest /rcj-soccer-sim/run-in-docker.sh /rcj-soccer-sim/worlds/soccer.wbt","title":"Extracting the recorded output"},{"location":"how_to_run_sim/#environment-variables","text":"The full list of environment variables supported by the Soccer Sim can be found below: RCJ_SIM_AUTO_MODE : If set (to any value), the simulation speed is set to fast, the recorders are started at the beginning and the application is automatically closed after the match is finished. Not set by default. RCJ_SIM_MATCH_TIME : Sets the number of seconds for which the match is to be played. Defaults to 600 (10 minutes). RCJ_SIM_REC_FORMATS : When set, the Soccer Sim starts a recording in these formats. The available options are mp4 and x3d . Multiple options can be set as well, separated by a comma. Not set by default. RCJ_SIM_OUTPUT_PATH : The path where the reflog outputs as well as the recordings are to be saved. Defaults to the reflog/ folder in controllers/rcj_soccer_referee_supervisor/ . Internal team-related variables: RCJ_SIM_TEAM_YELLOW_NAME : The name of the yellow team. Defaults to \"The Yellows\". RCJ_SIM_TEAM_Y_INITIAL_SCORE : The initial score of the yellow team. Defaults to 0. RCJ_SIM_TEAM_BLUE_NAME : The name of the blue team. Defaults to \"The Blues\". RCJ_SIM_TEAM_B_INITIAL_SCORE : The initial score of the blue team. Defaults to 0. RCJ_SIM_TEAM_YELLOW_ID : The ID of the yellow team used for internal identification. Defaults to \"The Yellows\". RCJ_SIM_TEAM_BLUE_ID : The ID of the yellow team used for internal identification. Defaults to \"The Blues\". RCJ_SIM_MATCH_ID : The ID of the match used for internal identification. Defaults to 1. RCJ_SIM_HALF_ID : The ID of the half time used for internal identification. Defaults to 1.","title":"Environment variables"}]}